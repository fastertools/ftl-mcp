use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use spin_sdk::http::Method;
use wasmcp::{
    mcp_plugin, JsonRpcError, McpHandler, McpResult, ServerInfo, Tool, ToolContent, ToolResult,
};

/// Random activity generator plugin
struct ActivityHandler;

#[mcp_plugin]
impl ActivityHandler {
    // HTTP handler will be generated by the macro
}

/// Bored API response structure
#[derive(Debug, Deserialize)]
struct ActivityResponse {
    activity: String,
    availability: f64,
    #[serde(rename = "type")]
    activity_type: String,
    participants: u32,
    price: f64,
    accessibility: String,
    duration: String,
    #[serde(rename = "kidFriendly")]
    kid_friendly: bool,
    link: String,
    key: String,
}

/// Generate a random activity suggestion
async fn fetch_random_activity() -> Result<String> {
    println!("ACTIVITY: Fetching random activity from API");
    
    let api_url = "https://bored-api.appbrewery.com/random";
    
    println!("ACTIVITY: Making request to: {}", api_url);
    
    let res: spin_sdk::http::Response = spin_sdk::http::send(
        spin_sdk::http::Request::builder()
            .method(Method::Get)
            .uri(api_url)
            .header("User-Agent", "WASMCP Activity Plugin/1.0")
            .body(())
            .build(),
    ).await?;
    
    let body = res.into_body();
    let body_str = String::from_utf8_lossy(&body);
    println!("ACTIVITY: Activity API response: {}", body_str);
    
    let activity: ActivityResponse = serde_json::from_slice(&body)
        .map_err(|e| anyhow::anyhow!("Failed to parse activity response: {}. Response was: {}", e, body_str))?;
    
    // Format the activity nicely
    let formatted_activity = format!(
        "ðŸŽ¯ **{}**\n\nâ„¹ï¸ **Details:**\nâ€¢ Type: {}\nâ€¢ Participants: {}\nâ€¢ Duration: {}\nâ€¢ Price: {}\nâ€¢ Accessibility: {}\nâ€¢ Kid Friendly: {}\nâ€¢ Availability: {:.1}%",
        activity.activity,
        activity.activity_type,
        activity.participants,
        activity.duration,
        if activity.price == 0.0 { "Free".to_string() } else { format!("${:.2}", activity.price) },
        activity.accessibility,
        if activity.kid_friendly { "Yes" } else { "No" },
        activity.availability * 100.0
    );
    
    println!("ACTIVITY: Successfully formatted activity");
    Ok(formatted_activity)
}

#[async_trait(?Send)]
impl McpHandler for ActivityHandler {
    fn server_info(&self) -> ServerInfo {
        ServerInfo {
            name: "activity-plugin".to_string(),
            version: "0.1.0".to_string(),
        }
    }

    fn has_tools(&self) -> bool {
        true
    }

    async fn list_tools(&self) -> McpResult<Vec<Tool>> {
        println!("ACTIVITY: list_tools called, returning random_activity tool");
        Ok(vec![Tool {
            name: "random_activity".to_string(),
            description: Some("Generate a random activity suggestion to cure boredom".to_string()),
            input_schema: Some(serde_json::json!({
                "type": "object",
                "properties": {},
                "required": []
            })),
        }])
    }

    async fn call_tool(&self, name: &str, _arguments: Option<serde_json::Value>) -> McpResult<ToolResult> {
        match name {
            "random_activity" => {
                println!("ACTIVITY: Generating random activity");
                
                let activity = fetch_random_activity().await
                    .map_err(|e| JsonRpcError::external_api_error(format!("Activity API error: {}", e)))?;
                
                Ok(ToolResult {
                    content: vec![ToolContent::Text {
                        text: activity,
                    }],
                    is_error: None,
                })
            }
            _ => Err(JsonRpcError::tool_not_found(name)),
        }
    }
}