use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use spin_sdk::http::Method;
use wasmcp::{
    mcp_plugin, JsonRpcError, McpHandler, McpResult, ServerInfo, Tool, ToolContent, ToolResult,
};

/// Weather plugin handler
struct WeatherHandler;

#[mcp_plugin]
impl WeatherHandler {
    // HTTP handler will be generated by the macro
}

/// Weather tool arguments
#[derive(Debug, Serialize, Deserialize)]
struct WeatherArgs {
    zipcode: String,
}

/// Weather API response structure
#[derive(Debug, Deserialize)]
struct WeatherResponse {
    hourly: HourlyWeather,
}

#[derive(Debug, Deserialize)]
struct HourlyWeather {
    time: Vec<String>,
    temperature_2m: Vec<f64>,
    relative_humidity_2m: Vec<f64>,
    wind_speed_10m: Vec<f64>,
}

#[async_trait(?Send)]
impl McpHandler for WeatherHandler {
    fn server_info(&self) -> ServerInfo {
        ServerInfo {
            name: "weather-plugin".to_string(),
            version: "0.1.0".to_string(),
        }
    }

    fn has_tools(&self) -> bool {
        true
    }

    async fn list_tools(&self) -> McpResult<Vec<Tool>> {
        println!("WEATHER: list_tools called, returning get_weather tool");
        Ok(vec![Tool {
            name: "get_weather".to_string(),
            description: Some("Get 24-hour weather forecast for a zipcode".to_string()),
            input_schema: Some(serde_json::json!({
                "type": "object",
                "properties": {
                    "zipcode": {
                        "type": "string",
                        "description": "US zipcode (e.g., '10001', '90210')"
                    }
                },
                "required": ["zipcode"]
            })),
        }])
    }

    async fn call_tool(&self, name: &str, arguments: Option<serde_json::Value>) -> McpResult<ToolResult> {
        match name {
            "get_weather" => {
                let args: WeatherArgs = serde_json::from_value(arguments.unwrap_or_default())
                    .map_err(|_| JsonRpcError::invalid_params("Invalid weather arguments"))?;
                
                let weather_info = fetch_weather(&args.zipcode).await
                    .map_err(|e| JsonRpcError::external_api_error(format!("Weather API error: {}", e)))?;
                
                Ok(ToolResult {
                    content: vec![ToolContent::Text {
                        text: weather_info,
                    }],
                    is_error: None,
                })
            }
            _ => Err(JsonRpcError::tool_not_found(name)),
        }
    }
}

/// Geocoding API response structure
#[derive(Debug, Deserialize)]
struct GeocodingResponse {
    #[serde(rename = "0")]
    result: Option<GeocodingResult>,
}

#[derive(Debug, Deserialize)]
struct GeocodingResult {
    lat: String,
    lon: String,
    display_name: String,
}

/// Get coordinates for a US zipcode using OpenStreetMap Nominatim API
async fn get_coordinates_for_zipcode(zipcode: &str) -> Result<(f64, f64)> {
    println!("WEATHER: Looking up coordinates for zipcode: {}", zipcode);
    
    let geocoding_url = format!(
        "https://nominatim.openstreetmap.org/search?format=json&country=US&postalcode={}&limit=1",
        zipcode
    );
    
    println!("WEATHER: Making geocoding request to: {}", geocoding_url);
    
    let res: spin_sdk::http::Response = spin_sdk::http::send(
        spin_sdk::http::Request::builder()
            .method(Method::Get)
            .uri(&geocoding_url)
            .header("User-Agent", "WASMCP Weather Plugin/1.0")
            .body(())
            .build(),
    ).await?;
    
    let body = res.into_body();
    let body_str = String::from_utf8_lossy(&body);
    println!("WEATHER: Geocoding API response: {}", body_str);
    
    let geocoding_results: Vec<GeocodingResult> = serde_json::from_slice(&body)
        .map_err(|e| anyhow::anyhow!("Failed to parse geocoding response: {}. Response was: {}", e, body_str))?;
    
    if let Some(result) = geocoding_results.first() {
        let lat: f64 = result.lat.parse()
            .map_err(|_| anyhow::anyhow!("Invalid latitude format"))?;
        let lon: f64 = result.lon.parse()
            .map_err(|_| anyhow::anyhow!("Invalid longitude format"))?;
        
        println!("WEATHER: Found coordinates for {}: {}, {} ({})", 
                zipcode, lat, lon, result.display_name);
        Ok((lat, lon))
    } else {
        Err(anyhow::anyhow!("Zipcode {} not found", zipcode))
    }
}

/// Fetch weather data from Open-Meteo API
async fn fetch_weather(zipcode: &str) -> Result<String> {
    println!("WEATHER: Fetching 24-hour forecast for zipcode: {}", zipcode);
    
    // Get real coordinates using geocoding API
    let (lat, lon) = get_coordinates_for_zipcode(zipcode).await?;
    
    let url = format!(
        "https://api.open-meteo.com/v1/forecast?latitude={}&longitude={}&hourly=temperature_2m,relative_humidity_2m,wind_speed_10m&forecast_days=1",
        lat, lon
    );
    
    println!("WEATHER: Making request to: {}", url);
    
    let res: spin_sdk::http::Response = spin_sdk::http::send(
        spin_sdk::http::Request::builder()
            .method(Method::Get)
            .uri(&url)
            .body(())
            .build(),
    ).await?;
    
    let body = res.into_body();
    let body_str = String::from_utf8_lossy(&body);
    println!("WEATHER: Weather API response: {}", body_str);
    
    let weather: WeatherResponse = serde_json::from_slice(&body)
        .map_err(|e| anyhow::anyhow!("Failed to parse weather response: {}. Response was: {}", e, body_str))?;
    
    // Format 24-hour forecast
    let mut forecast = format!("24-Hour Weather Forecast for {}\n\n", zipcode);
    
    for i in 0..std::cmp::min(24, weather.hourly.time.len()) {
        forecast.push_str(&format!(
            "{}: {:.1}Â°C, {}% humidity, {:.1} km/h wind\n",
            weather.hourly.time[i],
            weather.hourly.temperature_2m[i],
            weather.hourly.relative_humidity_2m[i] as i32,
            weather.hourly.wind_speed_10m[i]
        ));
    }
    
    Ok(forecast)
}

